---
outline: deep
---

# Hooks

As we have seen in the [quick start](./starting.md) and when we created our messages service in [the previous chapter](./services.md), Feathers services are a great way to implement data storage and modification. Technically, we could write our entire app with services but very often we need similar functionality across multiple services. For example, we might want to check for all services if a user is allowed to access it. With just services, we would have to implement this every time.

This is where Feathers hooks come in. Hooks are pluggable middleware functions that can be registered __around__, __before__, __after__ or on __errors__ of a service method. Just like services themselves, hooks are *transport independent*. They are usually also service independent, meaning they can be used with ​*any*​ service. This pattern keeps your application logic flexible, composable, and much easier to trace through and debug.
Hooks are commonly used to handle things like validation, authorization, logging, sending emails and more.

<BlockQuote type="tip">

A full overview of the hook API can be found in the [hooks API documentation](../../api/hooks.md). For the general design pattern behind hooks see [this blog post](https://blog.feathersjs.com/design-patterns-for-modern-web-apis-1f046635215).

</BlockQuote>

## Generating a hook

Let's generate a hook that lets us log the total runtime of a service method to the console.

```sh
npx feathers generate hook
```

We call our hook `log-runtime` and confirm the type with enter to make it an `around` hook.


<LanguageBlock global-id="ts">

Now update `src/hooks/log-runtime.ts` as follows:

</LanguageBlock>
<LanguageBlock global-id="js">

Now update `src/hooks/log-runtime.js` as follows:

</LanguageBlock>


```ts{4-9}
import type { HookContext, NextFunction } from '../declarations'

export const logRuntime = async (context: HookContext, next: NextFunction) => {
  const startTime = Date.now()
  // Run everything else (other hooks and service call)
  await next()

  const duration = Date.now() - startTime
  console.log(
    `Calling ${context.method} on ${context.path} took ${duration}ms`
  )
}

```

## Hook functions

A hook function is an `async` function that takes the [hook `context`](#hook-context) and a `next` function as the parameter. If the hook should only run __before__ or __after__ the service method, it does not need a `next` function. 

However since we need to store the start and end time here, we created an `around` hook. Hooks run in the order they are registered and if a hook function throws an error, all remaining hooks (and the service call if it didn't run yet) will be skipped and the error will be returned.

## Hook context

The hook `context` is an object which contains information about the service method call. It has read-only and writable properties.

Read-only properties are:

- `context.app` - The Feathers application object. This can be used to e.g. call other services
- `context.service` - The service this hook is currently running on
- `context.path` - The path (name) of the service
- `context.method` - The service method name
- `context.type` - The hook type (`before`, `after` or `error`)

Writeable properties are:

- `context.params` - The service method call `params`. For external calls, `params` usually contains:
  - `context.params.query` - The query (e.g. query string for REST) for the service call
  - `context.params.provider` - The name of the transport (which we will look at in the next chapter) the call has been made through. Usually `rest`, `socketio`, `primus`. Will be `undefined` for internal calls.
- `context.id` - The `id` for a `get`, `remove`, `update` and `patch` service method call
- `context.data` - The `data` sent by the user in a `create`, `update` and `patch` service method call
- `context.error` - The error that was thrown (in `error` hooks)
- `context.result` - The result of the service method call (in `after` hooks)

<BlockQuote type="tip">

For more information about the hook context see the [hooks API documentation](../../api/hooks.md).

</BlockQuote>

## Registering hooks

In a Feathers application generated by the CLI, hooks are being registered in the `<servicename>.ts` file. The hook registration object is an object with `{ around, before, after, error }` and a list or hooks per method like `{ all: [], find: [], create: [] }`.

<LanguageBlock global-id="ts">

To log the runtime of our `messages` service calls we can update `src/services/messages/messages.ts` like this:

</LanguageBlock>
<LanguageBlock global-id="js">

To log the runtime of all `messages` service calls we can update `src/services/messages/messages.js` like this:

</LanguageBlock>

```ts{16,33}
import { authenticate } from '@feathersjs/authentication'

import { hooks as schemaHooks } from '@feathersjs/schema'

import {
  messageDataValidator,
  messageQueryValidator,
  messageResolver,
  messageDataResolver,
  messageQueryResolver,
  messageExternalResolver
} from './messages.schema'

import type { Application } from '../../declarations'
import { MessageService, getOptions } from './messages.class'
import { logRuntime } from '../../hooks/log-runtime'

export * from './messages.class'
export * from './messages.schema'

// A configure function that registers the service and its hooks via `app.configure`
export const message = (app: Application) => {
  // Register our service on the Feathers application
  app.use('messages', new MessageService(getOptions(app)), {
    // A list of all methods this service exposes externally
    methods: ['find', 'get', 'create', 'update', 'patch', 'remove'],
    // You can add additional custom events to be sent to clients here
    events: []
  })
  // Initialize hooks
  app.service('messages').hooks({
    around: {
      all: [
        logRuntime,
        authenticate('jwt')
      ]
    },
    before: {
      all: [
        schemaHooks.validateQuery(messageQueryValidator),
        schemaHooks.validateData(messageDataValidator),
        schemaHooks.resolveQuery(messageQueryResolver),
        schemaHooks.resolveData(messageDataResolver)
      ]
    },
    after: {
      all: [schemaHooks.resolveResult(messageResolver), schemaHooks.resolveExternal(messageExternalResolver)]
    },
    error: {
      all: []
    }
  })
}

// Add this service to the service type index
declare module '../../declarations' {
  interface ServiceTypes {
    messages: MessageService
  }
}
```

<BlockQuote type="info">

`all` is a special keyword which means those hooks will run before the method specific hooks.

</BlockQuote>

Now every time a our messages service is accessed successfully the name, method and runtime will be logged.

## What's next?

In this chapter we learned how Feathers hooks can be used as middleware for service method calls without having to change our service. You may have noticed above that there are already some `schemaHooks` like `schemaHooks.validateQuery` or `schemaHooks.resolveResult` registered on our service which brings us to the next chapter on how to define our data model with [schemas and resolvers](./schemas.md).
